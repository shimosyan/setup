# CLAUDE.md

## Conversation Guidelines

- 常に日本語で会話する
- 不明点があれば実装する前に質問してください
- 作業前に実装計画を示してください。意図して特別な実装をする場合はその理由も示してください。

## Command Guidelines

- `cd` コマンドは標準のコマンドではありません。拡張機能を用いていおりそのまま使うとエラーに繋がるため、ディレクトリの移動は`builtin cd`を使用してください。

## Development Philosophy

### Code style

- コメントは常に日本語とする
- 余計な自明なコードコメントは残さない
- コメントの文章は体言止めとする

### Editorconfig

- **必ず** insert_final_newline = true を守る（すべてのファイルの最終行には必ず改行を入れる）
- trim_trailing_whitespace = true
- これらのルールは例外なく全てのファイル編集時に適用すること

### Git Commit

- コミットには署名鍵のパスフレーズを付与した署名が必要のため、コミット操作は不要です。ただし、ユーザーにてコミットするのでコミットメッセージの提案をするようにしてください。
- コミットメッセージは日本語にしてください
- さらにコミットメッセージには `feat(foo): ...` のようにsemantic commit messageを使うこと
- コミットメッセージの下に利用したプロンプトを `prompt:` から始めて書いてください

### Pull Request

- Pull Request は Draft Pull Request を書いてください。

### Terraform

- .tfファイルを変更した後は必ず`terraform fmt -recursive`コマンドを実行すること

### Node.js & Typescript

- Typescriptで開発するときはできるだけ"as T"構文を使わず、zodというライブラリでスキーマを定義して使う
- Typescriptで開発するときのテストフレームワークはvitestを使用する。ただし、@vitest/uiコンポーネントは不要
- Typescriptで開発するときのLinter及びFormatterはbiomeを使用する

## 設計の考え方

### 依存性注入とパターンの選択

依存関係の管理において、以下の原則を優先する：

#### **シンプルさを優先**

    - 複雑なパターン（Factory、DIコンテナ等）を導入する前に、本当に必要か検討する
    - YAGNI原則（You Aren't Gonna Need It）を意識し、将来の拡張性のための過度な抽象化は避ける

#### **Goのイディオムに従う**

    - 明示的な依存性注入を好む
    - コンストラクタで必要な依存関係を直接受け取る

    ```go
    // 推奨: 明示的で理解しやすい
    handler := NewHandler(client, config, service)

    // 避ける: 不必要な抽象化
    handler := factory.CreateHandler()
    ```

#### パターン適用の判断基準

- Factoryパターン: オブジェクトの生成手順が複雑で隠蔽が必要な場合のみ使用
- DIコンテナ: 依存関係が非常に複雑で、手動管理が困難な場合に検討
- 単純な構造体パラメータ: 引数が多い場合の第一選択肢

#### テスタビリティの確保

- インターフェースを適切に定義し、モックを注入可能にする
- 必要最小限の依存関係のみを知るように設計する

#### nil許容の回避

- 依存関係はコンストラクタで必須パラメータとして扱う
- nilチェックによる分岐は避け、常に有効な値を前提とする

### 命名規則

- 汎用的な名前より、具体的な責務を表す名前を選ぶ
  - ❌ NotionClient （汎用的すぎる）
  - ✅ OnboardingNotionRepository （具体的な用途が明確）

### Test-Driven Development (TDD)

- 原則としてテスト駆動開発（TDD）で進める
- 期待される入出力に基づき、まずテストを作成する
- テストの対象はビジネスロジックのみとする
- サードパーティのライブラリや外部エンドポイントなど我々が仕様をコントロールできない入出力を実装するときは読みやすさやテストの実装しやすさのため別関数に抽象化して実装する
  - 本項によって抽象化した処理は我々が仕様をコントロールできないためテストのメリットが無いことから、テストの対象外とする。テストコードも書いてはいけない。
- 実装コードは書かず、テストのみを用意する
- テストを実行し、失敗を確認する
- テストが正しいことを確認できた段階でタスクの一区切りとする
- その後、テストをパスさせる実装を進める
- 実装中はテストを変更せず、コードを修正し続ける
- すべてのテストが通過するまで繰り返す

## Long Task Execution

- 長時間かかるタスク（ビルド、テスト実行、大量のファイル処理など）を実行する際は、caffeinate-mcpを使用してシステムがスリープしないようにする
